//A period of time where users login and logout
//Find all the connected users at any given time

//Or : Given n intervals [ai, bi] find a point that intersects the most inter
/* quicksort intervals by ai
      for each intervals,
           queue.insert (bi)
           while( queue_head < ai)
               queue.pop()
          updatemax(ai, queue.size)

*/

public class Interval() {
    public double low;
    public double high;
}

public Node() {
    public List<Intervals> intervs = new ArrayList<Intervals>();
    public Node left;
    public Node right;
    
    stab
    
    query
}

public Tree() {
    public Node root;
    
    public void addNode(Node) {
        
    }
    
    public void removeNode(Node ) {
    }
    
    public void balance() {
    }
    
    public List<Intervals> search(double x) {
    }
    
    public List<Intervals> search(Interval interv) {
    }
}

 
